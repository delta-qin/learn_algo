

# 数据结构和算法从入门到放弃（java详细注释版）

**这一次，学算法是认真的！！！**

（每日更新中...欢迎指正）

## 文件夹说明：

- test文件夹为练习算法使用
- 其余文件夹按照分类存放，常见问题以及对应的注意事项都在注释中

## 涉及知识点

- code01 排序
    - S01 冒泡排序
    - S02 选择排序
    - S03 插入排序
    - S04 归并排序
    - S05 快速排序
    - S06 堆排序
    - S07 计数排序
    - S08 基数排序
    - S09 java自带比较器使用

- code02 二分查找
    - B01 有序数组的二分查找
    - B02 有序数组的左边界查找
    - B03 局部最小值查找
    - B04 山峰数组中值的查找：主要涉及向上取整的问题

- code03 链表
    - L01 反转链表
    - L02 打印公共子串
    - L03 回文判断
    - L04 给定pivot划分为左中右三部分
    - L05 复制有随机指针的链表（random指针可以是null）
    - L06 找（有无环）链表的交点
    
- code04 树
    - T01 深度遍历递归实现，对应位置做相关操作即可
    - T01 深度遍历非递归：使用栈实现，
        - 先序遍历：先放root，再压入**右子节点，再压入左**子节点
        - 中序遍历(**不熟练**)：**不断压入弹出每一个树的左边界**（当前弹出的节点有右节点，就将其左边界压入栈再弹出）(while条件中需要|| root！= null。因为只有右子节点 的树会不断有栈空出现，但是右子节点还没有遍历)
        - 后序遍历：使用两个栈，root压入S1,弹出后压入s2,**左子压s1,右子压入s1**，之后弹出压入s2，最后所有节点都放入了s2，而且上到下是先左后右最后中的顺序
    - T02 广度优先遍历：使用队列（LinkedList有add和poll，注意不能使用List多态接收，poll方法只有LinkedList有）实现，弹出节点孩子不为空就加入，直到栈为空结束
    - T03 获取树的最大宽度：首先使用队列实现宽度优先遍历，其次使用**map来保存每一个节点的层树**，这样当发现**节点所在层数与当前正在遍历的层数不一致的时候，说明换行了**，就记录之前层的最大节点数，直到队列为空得到最大宽度。
    - 获取树 的高度：
        - 使用map，保存节点的子节点所在的层（当前层+1），当发现取出来的节点的层数与当前层不一致就+1，**广度优先遍历**，结束就获得最大高度
        - 不使用map：递归左子树和右子树的最大高度+1就是当前树的最大高度，也就是**后序遍历**，结束就获得最大高度
    - T04 是否是二叉搜索树
        - **中序遍历，结果是升序即可**：
            - 借助额外的队列使得中序遍历和大小比较分离，
            - 不借助额外队列的话需要保证每次弹出的一个值大于自己之前弹出的一个值。
            - 不使用递归时候的中序遍历需要一个栈不断将最左边界压入，if 条件容易写错，弹出的值和当前的root容易混淆。
        - 后序遍历，**保证左子树和右子树都是BST，且中间大于左子树的最大值，小于右子树的最小值**。而且当前树的最值是通过左树和右树的最值共同求出来的。递归函数的返回值需要自己封装，因为需要三个值（最大值，最小值，以及是否为子树）
- T05 是否是完全二叉树：**宽度优先遍历**，当一个节点只有左孩子没有右孩子或者就没有左孩子也没有右孩子，他之后所有的节点都是叶子节点，否则不是CBT，有右孩子没有左孩子也不是BST
    - T06 是否是满二叉树：节点个数满足 2^n-1,n是层数，递归函数的返回值需要自己**封装节点的个数以及树的高度**。
    - T07 是否是平衡二叉树：**后序遍历**（明确AVL的三个条件，明确递归发生回溯DP的时候要和子树要什么信息）。递归函数的函数是返回当前树是不是AVL以及他的高度，所以返回值需要封装一下，计算返回值的时候使用两个子树的高度最大值+1，判断是否是AVL只需要看三个条件是否满足：左子树和右子树都是AVL。而且两个的高度之差是小于2的
    - T08 找两个节点的最小公共祖先：
        - 方法一：空间占用大。使用map来存放树上所有节点的father，根节点father是自己。从o1（包括o1，循环结束的条件是自己的父亲是自己）开始向上找到自己的父亲放到set里面直到根节点，从o2开始向上找（包含o2），如果发现set里面有自己的父亲，就直接返回父亲就是最小公共祖先
        - 方法二：空间占用小，难理解。
            - 递归结束条件：如果当前节点是空的（叶子节点的子节点），或者是要找的o1或者o2，那就没有必要继续往下找了
            - 情况一（返回当前节点）：如果当前节点的左子树和右子树都包含其中一个节点，那么当前节点就是最小公共父节点，
            - 情况二（返回当前节点的子节点）：如果当前节点只有一个子节点包含要找的节点，就返回这个节点，可能当前子节点就是公共节点，也可能当前子节点是其中一个要找的节点
    - T09 给定节点输出后继节点：
        - 如果当前节点有右子树，输出右子树的最左节点，
        - 如果当前节点没有右子树，往上找自己的父亲节点，只要自己不是自己父亲节点的右孩子，输出父亲节点，如果直到根节点（父节点是null）都是自己父节点的右孩子，那自己就是最后一个节点，返回null
    - T10 序列化树和反序列化树：注意特殊字符不要是-，因为负数的时候回出问题，起不到分割的效果
        - 先序序列化：直接使用递归先序就可以
        - 先序反序列化：转换为char数组之后，使用队列将其存起来，一个个出来的时候
        - 宽度优先序列化：中间空的节点使用特殊字符代替，恢复的时候遇到直接跳过
        - 宽度优先反序列化
    - T11 微软折纸问题
        - 转为树的中序遍历，根节点是凹，假设是false。这里没有现成的树，需要自己通过递归结束的条件模拟一个假设的树，
        - 定义递归函数：中序输出折痕，参数：当前折的次数，总共折的次数，是true还是false（是凹还是凸，是左子节点还是右子节点）
    - T12 前缀树
        - 有多少是以当前值为前缀的，可以通过path的值来判断
        - 设计节点的结构的时候不需要保存具体的数据，只需要按照数据的取值范围定义一个nexts数组即可，前缀树不是为了存数据，只是为了判断是否有数据，eg: 只有英文的字母，那就每一个节点直接定义一个长度为26的nexts数组，每一个元素都指向一个Node
    
- code05 图
    - 图的定义
        - 点
        - 边
        - 图：点集+边集
        - 图的转换器：将已知定义的图的数据转换为自己的套路
    - 宽度优先遍历
    - 广度优先遍历
    - 最短路径
    
- code06 贪心算法

- code07 递归算法

- code08 动态规划

## 项目运行

最简单的 javase 工程， 直接使用idea 打开项目即可运行。使用的jdk版本为1.8，编码格式为UTF-8

> 参考:左神算法,数据结构与算法之美，程序员代码面试指南
