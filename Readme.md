

# 数据结构和算法从入门到放弃（java详细注释版）

**这一次，学算法是认真的！！！**

（每日更新中...欢迎指正）

## 文件夹说明：

- test文件夹为练习算法使用
- 其余文件夹按照分类存放，常见问题以及对应的注意事项都在注释中

## 涉及知识点

### code01 排序

- S01 冒泡排序
- S02 选择排序
- S03 插入排序
- S04 归并排序
- S05 快速排序
- S06 堆排序
- S07 计数排序
- S08 基数排序
- S09 java自带比较器使用

### code02 二分查找

- B01 有序数组的二分查找
- B02 有序数组的左边界查找
- B03 局部最小值查找
- B04 山峰数组中值的查找：主要涉及向上取整的问题

### code03 链表

- L01 反转链表
- L02 打印公共子串
- L03 回文判断
- L04 给定pivot划分为左中右三部分
- L05 复制有随机指针的链表（random指针可以是null）
- L06 找（有无环）链表的交点

### code04 树

- T01 深度遍历递归实现，对应位置做相关操作即可
- T01 深度遍历非递归：使用栈实现，
    - 先序遍历：先放root，再压入**右子节点，再压入左**子节点
    - 中序遍历(**不熟练**)：**不断压入弹出每一个树的左边界**（当前弹出的节点有右节点，就将其左边界压入栈再弹出）(while条件中需要|| root！= null。因为只有右子节点 的树会不断有栈空出现，但是右子节点还没有遍历)
    - 后序遍历：使用两个栈，root压入S1,弹出后压入s2,**左子压s1,右子压入s1**，之后弹出压入s2，最后所有节点都放入了s2，而且上到下是先左后右最后中的顺序
- T02 广度优先遍历：使用队列（LinkedList有add和poll，注意不能使用List多态接收，poll方法只有LinkedList有）实现，弹出节点孩子不为空就加入，直到栈为空结束
- T03 获取树的最大宽度：首先使用队列实现宽度优先遍历，其次使用**map来保存每一个节点的层树**，这样当发现**节点所在层数与当前正在遍历的层数不一致的时候，说明换行了**，就记录之前层的最大节点数，直到队列为空得到最大宽度。
- 获取树 的高度：
    - 使用map，保存节点的子节点所在的层（当前层+1），当发现取出来的节点的层数与当前层不一致就+1，**广度优先遍历**，结束就获得最大高度
    - 不使用map：递归左子树和右子树的最大高度+1就是当前树的最大高度，也就是**后序遍历**，结束就获得最大高度
- T04 是否是二叉搜索树
    - **中序遍历，结果是升序即可**：
        - 借助额外的队列使得中序遍历和大小比较分离，
        - 不借助额外队列的话需要保证每次弹出的一个值大于自己之前弹出的一个值。
        - 不使用递归时候的中序遍历需要一个栈不断将最左边界压入，if 条件容易写错，弹出的值和当前的root容易混淆。
    - 后序遍历，**保证左子树和右子树都是BST，且中间大于左子树的最大值，小于右子树的最小值**。而且当前树的最值是通过左树和右树的最值共同求出来的。递归函数的返回值需要自己封装，因为需要三个值（最大值，最小值，以及是否为子树）
- T05 是否是完全二叉树：**宽度优先遍历**，当一个节点只有左孩子没有右孩子或者就没有左孩子也没有右孩子，他之后所有的节点都是叶子节点，否则不是CBT，有右孩子没有左孩子也不是BST
- T06 是否是满二叉树：节点个数满足 2^n-1,n是层数，递归函数的返回值需要自己**封装节点的个数以及树的高度**。
- T07 是否是平衡二叉树：**后序遍历**（明确AVL的三个条件，明确递归发生回溯DP的时候要和子树要什么信息）。递归函数的函数是返回当前树是不是AVL以及他的高度，所以返回值需要封装一下，计算返回值的时候使用两个子树的高度最大值+1，判断是否是AVL只需要看三个条件是否满足：左子树和右子树都是AVL。而且两个的高度之差是小于2的
- T08 找两个节点的最小公共祖先：
    - 方法一：空间占用大。使用map来存放树上所有节点的father，根节点father是自己。从o1（包括o1，循环结束的条件是自己的父亲是自己）开始向上找到自己的父亲放到set里面直到根节点，从o2开始向上找（包含o2），如果发现set里面有自己的父亲，就直接返回父亲就是最小公共祖先
    - 方法二：空间占用小，难理解。
        - 递归结束条件：如果当前节点是空的（叶子节点的子节点），或者是要找的o1或者o2，那就没有必要继续往下找了
        - 情况一（返回当前节点）：如果当前节点的左子树和右子树都包含其中一个节点，那么当前节点就是最小公共父节点，
        - 情况二（返回当前节点的子节点）：如果当前节点只有一个子节点包含要找的节点，就返回这个节点，可能当前子节点就是公共节点，也可能当前子节点是其中一个要找的节点
- T09 给定节点输出后继节点：
    - 如果当前节点有右子树，输出右子树的最左节点，
    - 如果当前节点没有右子树，往上找自己的父亲节点，只要自己不是自己父亲节点的右孩子，输出父亲节点，如果直到根节点（父节点是null）都是自己父节点的右孩子，那自己就是最后一个节点，返回null
- T10 序列化树和反序列化树：注意特殊字符不要是-，因为负数的时候回出问题，起不到分割的效果
    - 先序序列化：直接使用递归先序就可以，注意递归的结束条件，是为了解决每一个叶子节点 `if (root == null) return "#~";`
    - 先序反序列化：转换为char数组之后，使用队列将其存起来，一个个出来的时候还是中左右的顺序，还是先序递归恢复即可
    - 宽度优先序列化：中间空的节点使用特殊字符代替，恢复的时候遇到直接跳过
    - 宽度优先反序列化
- T11 微软折纸问题
    - 转为树的中序遍历，根节点是凹，假设是false。这里没有现成的树，需要自己通过递归结束的条件模拟一个假设的树，
    - 定义递归函数：中序输出折痕，参数：当前折的次数，总共折的次数，是true还是false（是凹还是凸，是左子节点还是右子节点）
- T12 前缀树
    - 有多少是以当前值为前缀的，可以通过path的值来判断
    - 设计节点的结构的时候不需要保存具体的数据，只需要按照数据的取值范围定义一个nexts数组即可，前缀树不是为了存数据，只是为了判断是否有数据，eg: 只有英文的字母，那就每一个节点直接定义一个长度为26的nexts数组，每一个元素都指向一个Node
- 有序表 logn
    - BST：查找（左小右大），新增（比大小，从头，往哪里滑），删除（叶子节点直接删，其他的则是：左树的最右替换，右树的最左替换）
        - 左旋：头节点往左边倒，右节点上来之后，右节点的左孩子给了头节点作为右孩子
        - 右旋：头节点往右边倒，左节点上来之后，左节点的右孩子给了头节点作为左孩子
        - AVL：利用左旋和右旋实现高度差不大于1，增删改查和BST一样，
            - 新增操作之后会在加入节点之后从当前节点往上查，所有节点为头的树是否有平衡性
            - 删除节点从删除位置节点开始往上查是否有平衡性，当删除的时候左右都有节点的时候
            - 平衡性被破坏的情况
                - LL型：左孩子的左边过长，单次右旋即可
                - RR型：右孩子的右边过长，单次左旋即可
                - LR型：左孩子的右边过长，最低层的开始不平衡的节点想办法变成头部，先左旋再右旋一般就可以了
                - RL型：右树的左边过长，最底层的开始不平衡的节点想办法变成头部，先右旋再左旋一般就可以了
        - 红黑树：利用左旋和右旋，平衡规则是自己定义的，与AVL区别判断平衡性的方式不一样
            - 每一个节点不是红就是黑
            - 树的头部和叶节点（null）是黑的（叶节点是null节点）
            - 红黑不相邻
            - 从头部出发到叶节点的每一个路径，要求黑节点的数量一样（因为这个要求，所以最长的路径（黑红相间）和最短的路径（全黑）也就相互差一倍）
        - SB：利用左旋和右旋，平衡规则是自己定义的
            - 每一个叔叔树的大小都不要小于侄子树的大小
            - LR型：左孩子的右孩子大于叔叔，想办法让左孩子的右孩子变成头部
    - 跳表：单链表的改写
        - 

### code05 图

- 图的定义
    - 点：值value，入度in，出度out，自己的边集`ArrayList<Edge> edges`，自己的邻接点集`ArrayList<Node> nexts`
    - 边：权重weight，入节点fromNode，出节点toNode
    - 图：点集`HashMap<Integer,Node> map`,边集`HashSet<Edge> edge`
    - 图的转换器：将已知定义的图的数据转换为自己的套路，最后得到Graph对象
- G01 宽度优先遍历：维护一个队列Queue记录当前需要遍历的节点，维护一个set记录已经加入到**过**的队列的节点，保证每次加入到队列的都是之前没有加入到队列过的节点
- G02 深度优先遍历：维护一个栈
- G06 迪杰斯特拉：
    - **只用普通map实现**：需要记录当前是否已经锁住的set，记录节点到head的最小距离的map，获取要锁住的节点的方法就是获取当前没有锁住而且是到head的距离最小的节点。拿到最小节点就开始处理所有的邻接节点。没加入过map的就加，加入过的如果比之前的小的方案就要更新map，知道所有的节点都加入到上锁的set里面，处理结束，返回map
    - **使用自定义小根堆实现**：每次遍历当前节点的所有邻接节点，
        - 将没有加入过的节点加到小根堆，（插入的时候是上冒）
        - 已经加入但是`当前节点到head的距离+当前节点到邻接点的距离`小于`之前head到邻接点的距离`，就要在堆里面更新当前节点对应的值（到head的最小距离），并且调整小根堆的位置（数组交换，以及修改记录Node所在所以的map）使其依旧是小根堆（这个其实也相当于上冒）
        - 当从堆里面弹出的时候，是删除，首先顶和最后一个交换，之后顶自己下沉到合适位置

### code06 贪心算法

优先级队列（大堆小堆），比较器（借助比较逻辑排序，可以用来排序，也可以用来组成堆），不断拿出最值的数据进行操作，最后得到的结果也是最值。但是贪心策略需要尝试，考场证明是不可能的。

- 最值的核心就是穷举，这是因为只要我们能够找到所有可能的答案，从中挑选出最优的 解就是算法问题的结果。在没有优化的情况下，穷举从来就不算是一个好方法。所以出现使用了贪心算法，使用局部最优思想解题（即从问题的某一个初始解出发逐步逼近给定的目标，以**尽可能快的速度**去求得更好的解，当达到算法中的某一步不能再继续前进时， 算法停止）。但是贪心不能保证求得的最后解是最佳的；不能用来求最大或最小解问题；只能求满足某些约束条件的可行解的范围。往往需要使用回溯来优化贪心算法，否则就会导致算法失效。
- G01：
- G02 分金条最小代价：逆向思维，从小贪心到大，每次都取小堆中两个元素出来加和之后放回去，再取两个出来加和放回去，直到最后只有一个元素，返回就是最小代价。
    - 是一种从结果得到方案的思路，
    - 每一步都是所有当中最小的，最后得到的结果也一定是最小的
    - 关注最后让花费大是为什么，就是切割为两份时候二者的和不是所有方案中最小的。如何得到所有排列组合方案中最小的，不如不用分而是用拼的方式，起步就是用最小的
    - 哈夫曼编码：初识哈夫曼，居然不知道这就是贪心，**当一个问题是求代价时，它总共的代价是由子代价的某种计算形成的，这种问题都可以考虑采用哈夫曼编码的贪心策略去解决**
    - 经典的哈夫曼编码问题，建立小根堆，每次从小根堆的堆顶取走两个元素。再将这两个元素的和放进小根堆中，直到小根堆只剩下一个元素，即为分割的最小代价
    - 最小堆的关键在于每一次加入之后都会会重新调整，所以加和之后的数据不一定在下一次加和中用到，因为有更小的加和方案，所以只用最大作为切割标准就是不对的
- G03
- G04
- G05 
- G06 硬币找零：贪心算法过于贪心的时候需要使用回溯（局部最优导致的问题）。回溯解决准确性的问题，动态规划解决时间复杂度的问题
- 长度为L的绳子，求绳子最多能覆盖其中的几个点。

### code07 暴力递归算法：

（**搞清楚试法**，就奠定了动态规划的基础，试法是有套路的天赋，动态规划是套路）暴力递归就是尝试。1，把问题转化为规模缩小了的同类问题的子问题 2，有明确的不需要继续进行递归的条件(base case) 3，有当得到了子问题的结果之后的决策过程 4，不记录每一个子问题的解、一定要学会怎么去尝试，因为这是动态规划的基础

- R01 汉诺塔问题：关注子问题
    - 1 ~  i-1 从from移动other
    - i 从from移动到 to
    - 1 ~ i-1 从other移动到to
    - 方法定义，i 从哪里出发，到哪里去，另外一个不需要管的other是什么
- R02 打印一个字符串的全部子序列
- R03 打印一个字符串的全部排列，要求不要出现重复的排列
- R04 给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。
- R05 规定1和A对应、2和B对应、3和C对应... 那么一个数字字符串比如"111"，就可以转化为"AAA"、"KA"和"AK"。 给定一个只有数字字符组成的字符串str，返回有多少种转化结果。
- R06 给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物 品不能超过这个重量。返回你能装下最多的价值是多少？
- R07 给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸 牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A 和玩家B都绝顶聪明。请返回最后获胜者的分数。
- R08 N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列， 也不在同一条斜线上。 给定一个整数n，返回n皇后的摆法有多少种。

### code08 动态规划DP

**尝试方法的递归版本（原始和业务强相关，最关键，后面的都是套路化的）**，从递归结构就可以改出来动规版本。**记忆化搜索DP**（只需将递归按照固定的套路修改为递归的版本就可以），不会严格去找每一个状态 的依赖顺序，**严格表结构DP**就是严格去找每一个状态 的依赖顺序。位置依赖完全整理出来才可以更加精致的优化动态规划。

> 步骤
>
> 1)找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了
>
> 2)把可变参数的所有组合映射成一张表，有 1 个可变参数就是一维表，2 个可变参数就 是二维表，......
>
> 3)最终答案要的是表中的哪个位置，在表中标出
>
> 4)根据递归过程的 base case，把这张表的最简单、不需要依赖其他位置的那些位置填好 值
>
> 5)根据递归过程非base case的部分，也就是分析表中的普遍位置需要怎么计算得到，那 么这张表的填写顺序也就确定了
>
> 6)填好表，返回最终答案在表中位置的值
>
> 
>
> 确定递归方法
>
> 递归方法加缓存变成记忆化的方法
>
> 严格位置表依赖的方法
>
> ​	可变参数变化范围，以及个数
>
> ​	计算的终止位置
>
> ​	base case 推出不用计算的位置
>
> ​	位置依赖
>
> ​	确定依次计算的顺序
>
> ​			将递归的过程拷贝过来就行了

- N长度中，机器人在M位置走k步到达p的方法数问题：
  - 方法一：暴力递归
    - 试法：暴力递归函数的意义（总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数）
    - base case：还剩0步的时候，如果当前位置已经来到 p 了，就返回1表示一种走法成立，否则返回0当前方法行不通。
    - 有路走的时候当前在1位置，必须往右走，后续的方法有 walk(N, 2, rest - 1, P);
    - 有路走的时候当前在N位置，必须往左走，后续的方法有 walk(N, N - 1, rest - 1, P);
    - 有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以走向左，也可以走向右walk(N, cur + 1, rest - 1, P) + walk(N, cur - 1, rest - 1, P);
    - int walk(int N, int cur, int rest, int P) 可变参数就是 cur 和 rest，这两个固定下来了结果就固定了。
  - 方法二：记忆化搜索：暴力递归存在重复计算，使用备忘录dp来缓存，存放的值就是递归函数要返回的值，几维数组由有几个可变参数决定，，当前题目含义就是**还剩下K步到达P位置的值**
  - 方法三：记忆化搜索+位置依赖=动态规划：，将base case转换为初始值，根据递归函数将函数调用变成dp的依赖关系，确定好可变参数的取值范围，确定好dp矩阵上哪些数据是已知的，确定如何移动才能满足下一次用的时候依赖的上一次数据已经算出来了，一般base case 会覆盖一列或者一行数据，之后for循环外层就按照这个来，每次计算的时候都依赖前面的列或者行，
    - 画出dp矩阵：明确已知的值（base case），明确要求的值的位置（作为返回值），明确取值返回（for的取值），明确运动方向，谁嵌套谁（for的嵌套问题，已知数据多的行或列对应的变量作为外层循环）
    - 依赖关系寻找：直接将递归函数的调用转换为数组的运算即可
    - 在记忆化搜索中使用的占位初始化这里一般要去掉
- 硬币个数不限，种类限制，求组成给定值的最小货币个数问题：
  - 方法一：暴力递归
    - 试法：从左到右，index从左到右
    - 递归函数意义：当前使用到index位置的硬币，剩余的需要凑的是rest，凑够当前rest需要的最少硬币
    - base case：rest是负数表示已经失败了，返回-1，index为最大值的时候也就是硬币都用完了，rest不为0就是-1表示失败，rest为0就是成功，不需要当前硬币就是0。
    - 中间情况：使用当前硬币，调用函数记得减去当前的钱数，不使用硬币就不减去钱数。注意当前函数返回的时候分情况讨论，因为都可能返回-1，都不是-1就需要使用最小的来返回，计算的时候使用的了硬币的记得+1
  - 方法二：记忆化搜索：暴力递归存在重复计算，使用备忘录dp来缓存，存放的值就是递归函数要返回的值，几维数组由有几个可变参数决定，，当前题目含义就是**从index位置往后的硬币，凑够rest的钱数需要的最少硬币数**，使用index为x, rest为y, 之后就是把递归的内容复制过来调用函数的地方修改为数组替换，并且在开始的时候使用缓存拦截，命中直接返回。本质还是递归，只是加了缓存
  - 方法三：记忆化搜索+位置依赖=动态规划：
    - 画出dp矩阵：明确已知的值（base case），明确要求的值的位置（作为返回值），明确取值返回（for的取值），明确运动方向，谁嵌套谁（for的嵌套问题，已知数据多的行或列对应的变量作为外层循环）
    - 依赖关系寻找：直接将递归函数的调用转换为数组的运算即可
    - 在记忆化搜索中使用的占位初始化这里一般要去掉，这里留下来使用-2
- 象棋跳到达指定的xy位置总共必须step，一共的走法：
  - 递归版：basecase越界的时候直接返回0，不越界的时候周围的8个位置就是到达自己之前的走法，直接加起来就是自己的走法。
  - 严格表结构版本：递归可以看到，值的依赖只是依赖于自己周围的8个角，有三个可变参数，x，y，step。所以需要设置三维的dp数组，base case就是step 为0 的时候，只有目标是00的时候才有一种走法，其余都是0种走法这就是初始条件，step的为0的层。上层都依赖下层。三层for循环，里面的xy的顺序无所谓。



### 字符串匹配

- 文本串和模式串，**在文本串中找模式串起始索引位置**
- 方法一：暴力枚举：文本串外循环n次，子循环内循环 m 次匹配，复杂度是 n * m 
- 方法二 set：每一个开头，对应的长度，放到set里面，查询是否有来决定
- 方法三 KMP算法 ： 
    - next数组：也就是前缀数组，长度和模式串一致，每一个位置表示当前位置之前的最大前缀长度是多少。
    - next数组每一个元素，也就是模式串当前元素之前的最大前缀长度的计算： 前缀长度后缀长度，二者相等（不是对称）的时候的最大长度就是最大 **相等前缀长度**，注意不能取全部长度作为前后缀没有意义，**aabcaa的就是2，aaaaaa就是5**（比的时候从前往后和从后往前一起，相等即可不是对称相等）
    - next数组前两个元素，人为规定是-1 和 0，之后的元素计算方式就是上面写的，所以构造完之后，**任何一个模式串中的字符之前的最长相等前缀的长度信息**都有了。
    - next数组如何**加速**，字符第一次出现不等的情况，原始的方式是从文本串跳回到i+1位置开始比，模式串跳回到0位置。现在next告诉了当前元素的之前的最大前缀和最大后缀匹配长度（也就是next数组当前索引位置对应的值），我们就可以让文本串当前位置不动，让模式串的指针不是回到0而是来到最大前缀长度的下一个位置，之后开始一起移动指针比较是否一致，就把之前已经发生的比较利用起来了，文本串是从刚刚比较完的下一个未比较的开始比的
        - 注意这里可以这样是因为可以证明之前的处于最长前缀内部为开端的位置不可能出现匹配。（证明略）
        - 下图中紫色部分是需要理解的精华部分（因为是对称位置的相等，所以这样加速就是对的，从二者的下一个位置开始比较）
        - ![KMP](./img/Readme/KMP.jpeg)
- Manacher算法：求最长回文子串

### 大数据，资源限制类题目（一个模糊的问题能不能问的很清楚）

- 布隆过滤器：边添加集合的时候边查询
    - 一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
    - 失误率。资源大小
- hash函数分流：小文件里面统计多台机器，最后把信息汇总
    - 一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
- 一致性问题：解决数据服务器的负载管理问题
- 并查集做岛问题的并行计算
- 位图：空间比hash分流小
    - 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的 内存，找出所有出现了两次的数。
- 分段统计：空间比位图还小
- 堆，外排序做多个处理单元的结果的合并
    - 某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100 词汇的可行办法
        - 二维堆，局部的小排名是一个堆，每一个堆的顶拿出来作为新堆，取出新堆就从原来的堆里面补充上来，直到满足
    - 10G无序文件，只有5G内存，得到有序文件
        - 

- 位运算
    - 给定两个有符号32位整数a和b，返回a和b中较大的。
    - 判断一个32位正数是不是2的幂、4的幂
    - 给定两个有符号32位整数a和b，不能使用算术运算符，分别实现a和b的加、减、乘、除运 算

## 项目运行

最简单的 javase 工程， 直接使用idea 打开项目即可运行。使用的jdk版本为1.8，编码格式为UTF-8

> 参考:左神算法,数据结构与算法之美，程序员代码面试指南
